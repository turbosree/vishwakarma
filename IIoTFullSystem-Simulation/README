// ------------------------------------------------------------------------------------------
/// \file                  README
///                        Also included HOWTO to get started with project and build steps
/// \author                Sreejith.Naarakathil@gmail.com
/// \date                  27/3/2021
// ------------------------------------------------------------------------------------------

1. Industrial Internet of Things Full System Model
--------------------------------------------------
A contemporary industrial internet of things full system could be visualized as below. Each layer does a specific function required by a distributed control system and passes the outcome to the next layer forming a value stream from the edge to the cloud. It is an attempt to model the node (any peice of hardware), network and communication in each layer for the purposes of simulation and performance modeling of complex systems.

        S   E   G   C   I           Layers of the IIoT full system model (S-Sensor, E-Edge, G-Gateway, C-Cloud, I-Intelligence
      ---------------------
  <-> | A |   | B | C | P | <->     Value stream (Data, Control, Monitoring etc.). A, B, C, P are arbitrary messages.
      ---------------------

Current implementation only model the filed bus system (1) and just run dummy systems for (2) and (3).
<edge>-----(1)-----<gateway>-----(2)------<cloud-native-environment>-----(3)------<services>

The system is modeled using descrete timer events generated by a real-time thread using Linux Kernel real-time extensions. The simulation uses a pipeline approach to do the various stages in each layer and stote the state of each stage every cycle of the simulation run. Uses a separate thread to output the results without impacting the similation thread. Simulation uses 2 ingress points on either side of the pipeline for integration purposes at edge level and cloud level.

This simulation currently only works on Linux platform. The Linux real-time approach is taken from my own article in the "Linux Gazette" published online here: https://linuxgazette.net/118/sreejith.html

2. How to build the Simulation from source?
-------------------------------------------
System details :
  Operating System: Linux Mint 18.3
            Kernel: Linux 4.15.0-139-generic
      Architecture: x86-64

g++ (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609

From a linux console, go to the source code folder and execute command: make
Use 'make clean' to clean the root folder of source code

To execute the Simulation with out batch randomization: ./RunSimulation 1000000 3 100 0 > result_without_batch_randomization.txt
To execute the Simulation with batch randomization:     ./RunSimulation 1000000 3 100 1 > result_with_batch_randomization.txt

Sample test results in the root folder of the source: result_without_batch_randomization.txt, result_with_batch_randomization.txt

3. Result
---------

Case-1: Simulation with out batch randomization
-----------------------------------------------

Simulation cycle:     99
Current batch:        | C | -->
Bus status: | C | Q |   |   |   |
Device status:  [   ][   ]---[   ][   ]   [ A ][ C ]---[   ][   ]   [ A ][   ]---[ A ][ B ]   [   ][   ]---[   ][   ]   [   ][   ]---[   ][   ]   

Uptime (secs): 99    TypeA: 0    TypeB: 0    TypeC: 0    TypeP: 19    TypeQ: 17    Queued: 320    Throughput: 36

Number of items created: 616
Number of items destroyed: 289

How many desired response data messages arrive at the cloud end: 36 (Please see 'Throughput' above.)
How many messages of each type go through the value stream without being processed by any edge device:
TypeA: 0    TypeB: 0    TypeC: 0
At the end of 100th simulation cycle the following messages are in progress at various layers of the system:
Bus1-Device1: A,C
Bus2-Device1: A
Bus2-Device2: A,B
Bus0(Ingress port for the simulation): C
Bus1: Q

Test: From real world experience, we can say that number of messages fed into the system should be equal to the total number of messages in processing and messages consumed by devices for the desired response data (P & Q). 
289 + 2(Bus1) + 2(Bus2 Device2) + 1(Bus2 Device1) + 2(Bus1 Device1) + 320 = 616

4. Running in debugger:
-----------------------
gdb -i=mi --args RunSimulation 1000000 3 100 0

5. Build and distribute the application using docker
----------------------------------------------------
From a docker enabled environment (linux or windows), go to the folder containing the Dockerfile and execute command:

To build the application:
docker build -t iiot-sim:2.0.0 .

To run the application:
docker run iiot-sim:2.0.0

To inspect the image and files:
docker run -it iiot-sim:2.0.0 sh

TODO: Add image to docker hub
